#include "modbus.h"
#include "uart.h"


uint8_t mod_addr = 0;
uint8_t mod_buf[11];

void modbus_init(uint8_t addr)
{
	mod_addr = addr;
}

void modbus_handle(uint8_t* rx,uint8_t len)
{
	uint16_t start_addr,regnum; //crc,crcin;
	
	uint8_t arr_len=0;
	
//	if(rx[0] == 0xaa)
//	{
//		if(rx[1] == 0x55)
//		{
//			mod_addr = rx[2];
////			flash_write(mod_addr);
//			tx_buf[0]=0x55;
//			tx_buf[1] = 0xaa;
//			rs485_send(tx_buf,2);
//			return;
//		}
//	}
	
	if(rx[0] != mod_addr)
	{
		arr_len=0;
		mod_buf[arr_len++] = 0xaa;
		mod_buf[arr_len++] = ADDR_ERR;
		mod_buf[arr_len++] = 0x55;
		modbus_send(mod_buf,arr_len++);
		return;
	}
	
//	crcin = rx[len-2];
//	crcin = crcin << 8 | rx[len - 1];
	
	start_addr = rx[len-2];
	start_addr = start_addr << 8 | rx[len - 1];


	regnum = crc16bitbybit(rx,len-2);
	regnum = regnum>>8 | regnum<<8;

	if(start_addr != regnum)
	{
		arr_len = 0;
		mod_buf[arr_len++] = 0xaa;
//		mod_buf[arr_len++] = len;
//		mod_buf[arr_len++] = rx[len-2];
//		mod_buf[arr_len++] = rx[len - 1];
//		
		mod_buf[arr_len++] = CRC_ERR;
//		mod_buf[arr_len++] = crc >> 8;
//		mod_buf[arr_len++] = crc;		
//		mod_buf[arr_len++] = 0x55;
		modbus_send(mod_buf,arr_len++);
		return;
	}
	
	arr_len = 0;
	mod_buf[arr_len++] = mod_addr;
	mod_buf[arr_len++] = rx[1];
	if(rx[1] == 3)
	{
		start_addr = rx[2];
		start_addr = start_addr << 8 | rx[3];
		
		regnum = rx[4];
		regnum = regnum <<8 | rx[5];
		
//		mod_buf[arr_len++] = regnum*2;
		
//		for(crc= start_addr*2 ; crc<(start_addr*2+regnum*2); crc++)
//		{
//			mod_buf[arr_len++] = 0;//data_buf[crc];
//		}
		
		if(start_addr == 0)
		{
			if(regnum == 1)
			{
				mod_buf[arr_len++] = 2;
				start_addr = s1*10+s2;
				mod_buf[arr_len++] = start_addr>>8;
				mod_buf[arr_len++] = start_addr;
			}
			if(regnum == 2)
			{
				mod_buf[arr_len++] = 4;
				start_addr = s1*10+s2;
				mod_buf[arr_len++] = start_addr>>8;
				mod_buf[arr_len++] = start_addr;
				start_addr = w1*10+w2;
				mod_buf[arr_len++] = start_addr>>8;
				mod_buf[arr_len++] = start_addr;
			}
		}
		else if(start_addr == 1)
		{
				mod_buf[arr_len++] = 2;
				start_addr = w1*10+w2;
				mod_buf[arr_len++] = start_addr>>8;
				mod_buf[arr_len++] = start_addr;
		}
		
		start_addr = crc16bitbybit(mod_buf,arr_len);
		mod_buf[arr_len++] = start_addr;
		mod_buf[arr_len++] = start_addr>>8;
		
//		for(start_addr=0; start_addr<8; start_addr++)
//		{
//			mod_buf[start_addr] = start_addr;
//		}
		
		modbus_send(mod_buf,arr_len++);
	}
	
//	else if(rx[1] == 6)
//	{
//		start_addr = rx[2];
//		start_addr = start_addr << 8 | rx[3];
//				
////		data_buf[start_addr * 2] = rx[4];
////		data_buf[start_addr * 2 + 1] = rx[5];
//		
//		tx_buf[2] = rx[2];
//		tx_buf[3] = rx[3];
//		
////		tx_buf[4] = tx_buf[start_addr * 2];
////		tx_buf[5] = tx_buf[start_addr * 2 + 1];
//		
//		crc = crc16table(tx_buf,6);
//		tx_buf[6] = crc;
//		tx_buf[7] = crc>>8;
//		modbus_send(tx_buf,8);
//		
////		if(start_addr == 4)
////		{
////			mod_addr = data_buf[9];
////		}
//	}
}
 
void modbus_send(uint8_t* rxbuf,uint8_t len)
{
	unsigned char i;
	
	for(i=0; i<len; i++)
	{
		SendOneByte(rxbuf[i]);
	}
}
 
///* Table of CRC values for high¨Corder byte */
//const uint8_t xdata crctablehi[] = {
//	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
//	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
//	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
//	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
//	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
//	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
//	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
//	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
//	0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
//	0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
//	0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
//	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
//	0x40
//};
///* Table of CRC values for low¨Corder byte */
//const uint8_t xdata crctablelo[] = {
//	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
//	0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
//	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
//	0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
//	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
//	0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
//	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
//	0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
//	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
//	0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
//	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
//	0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
//	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
//	0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
//	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
//	0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
//	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
//	0x40
//};
// 
//uint16_t crc16table(uint8_t *ptr, uint16_t len)
//{
//	uint8_t crchi = 0xff;
//	uint8_t crclo = 0xff; 
//	uint16_t index;
//	while (len--) 
//	{
//		index = crclo ^ *ptr++; 
//		crclo = crchi ^ crctablehi[index];
//		crchi = crctablelo[index];
//	}
//	return (crchi << 8 | crclo);
//}

//const code uint16_t polynom = 0xA001;

#define polynom 0xA001

uint16_t crc16bitbybit(uint8_t *ptr, uint16_t len)
{
	uint8_t i;
	uint16_t crc = 0xffff;
 
	if (len == 0) {
		len = 1;
	}
	while (len--) {
		crc ^= *ptr;
		for (i = 0; i<8; i++)
		{
			if (crc & 1) {
				crc >>= 1;
				crc ^= polynom;
			}
			else {
				crc >>= 1;
			}
		}
		ptr++;
	}
	return(crc);
}
 
//const uint16_t xdata crctalbeabs[] = { 
//	0x0000, 0xCC01, 0xD801, 0x1400, 0xF001, 0x3C00, 0x2800, 0xE401, 
//	0xA001, 0x6C00, 0x7800, 0xB401, 0x5000, 0x9C01, 0x8801, 0x4400 
//};
// 
//uint16_t crc16tablefast(uint8_t *ptr, uint16_t len) 
//{
//	uint16_t crc = 0xffff; 
//	uint16_t i;
//	uint8_t ch;
// 
//	for (i = 0; i < len; i++) 
//	{
//		ch = *ptr++;
//		crc = crctalbeabs[(ch ^ crc) & 15] ^ (crc >> 4);
//		crc = crctalbeabs[((ch >> 4) ^ crc) & 15] ^ (crc >> 4);
//	}
//	
//	return crc;
//}



